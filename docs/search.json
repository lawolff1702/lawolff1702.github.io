[
  {
    "objectID": "posts/new-test-post/index.html",
    "href": "posts/new-test-post/index.html",
    "title": "Second Post",
    "section": "",
    "text": "This is an example of the blog posts that you’ll submit as your primary form of learning demonstration in CSCI 0451. I created this post by modifying the file posts/example-blog-post/index.ipynb in VSCode. You can also use JupyterLab for this editing if you prefer. Finally, it is possible to write blog posts without using notebooks by writing .qmd files, as illustrated here."
  },
  {
    "objectID": "posts/new-test-post/index.html#math",
    "href": "posts/new-test-post/index.html#math",
    "title": "Second Post",
    "section": "Math",
    "text": "Math\nIn addition to regular text using the Markdown specification, you can also write mathematics, enclosed between dollar signs. The syntax for writing math is very similar to the syntax used in the \\(\\LaTeX\\) markup language. For example, $f(x) \\approx y$ renders to \\(f(x) \\approx y\\). To place complex mathematical expressions on their own lines, use double dollar signs. For example, the expression\n$$\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2$$\nrenders to:\n\\[\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2\\;.\\]\nBehind the scenes, math is powered by the MathJax engine. For more on how to write math, check this handy tutorial and quick reference."
  },
  {
    "objectID": "posts/example-blog-post/index.html",
    "href": "posts/example-blog-post/index.html",
    "title": "Hello Blog",
    "section": "",
    "text": "from source import Perceptron\nThis is an example of the blog posts that you’ll submit as your primary form of learning demonstration in CSCI 0451. I created this post by modifying the file posts/example-blog-post/index.ipynb in VSCode. You can also use JupyterLab for this editing if you prefer. Finally, it is possible to write blog posts without using notebooks by writing .qmd files, as illustrated here."
  },
  {
    "objectID": "posts/example-blog-post/index.html#math",
    "href": "posts/example-blog-post/index.html#math",
    "title": "Hello Blog",
    "section": "Math",
    "text": "Math\nIn addition to regular text using the Markdown specification, you can also write mathematics, enclosed between dollar signs. The syntax for writing math is very similar to the syntax used in the \\(\\LaTeX\\) markup language. For example, $f(x) \\approx y$ renders to \\(f(x) \\approx y\\). To place complex mathematical expressions on their own lines, use double dollar signs. For example, the expression\n$$\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2$$\nrenders to:\n\\[\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2\\;.\\]\nBehind the scenes, math is powered by the MathJax engine. For more on how to write math, check this handy tutorial and quick reference."
  },
  {
    "objectID": "posts/Classifying Palmer Penguins/index.html",
    "href": "posts/Classifying Palmer Penguins/index.html",
    "title": "Classifying Palmer Penguins",
    "section": "",
    "text": "Abstract\nThis blog post will explore the use of machine learning to classify Palmer Penguins based on their physical measurements and location. Beginning with data preprocessing and exploration cleaned up and contextualized our analysis for the subsequent model training. We employed logistic regression and selected features in a repeatable and cross-validated manor achieving an 100% testing accuracy when classifying the penguins. This result shows the effectiveness of using culmen length, culmen depth, and island location as predictive features. The blog post also lays out provides a tradition workflow to use machine learning on ecological datasets.\n\n\nfrom IPython.display import Image, display\ndisplay(Image(filename='palmer_station.png'))\n\n\n\n\n\n\n\n\nImage Source\n\n\nData\nThis code block handles our Training Data Acquisition from the Palmer Penguins data set. This collection holds data for three types of Penguins living across three islands. There is a mix of quantitative measurements and qualitative observations.\n\nimport pandas as pd\n\ntrain_url = \"https://raw.githubusercontent.com/PhilChodrow/ml-notes/main/data/palmer-penguins/train.csv\"\ntrain = pd.read_csv(train_url)\n\nHere is a first look at our raw data:\n\ntrain.head()\n\n\n\n\n\n\n\n\nstudyName\nSample Number\nSpecies\nRegion\nIsland\nStage\nIndividual ID\nClutch Completion\nDate Egg\nCulmen Length (mm)\nCulmen Depth (mm)\nFlipper Length (mm)\nBody Mass (g)\nSex\nDelta 15 N (o/oo)\nDelta 13 C (o/oo)\nComments\n\n\n\n\n0\nPAL0809\n31\nChinstrap penguin (Pygoscelis antarctica)\nAnvers\nDream\nAdult, 1 Egg Stage\nN63A1\nYes\n11/24/08\n40.9\n16.6\n187.0\n3200.0\nFEMALE\n9.08458\n-24.54903\nNaN\n\n\n1\nPAL0809\n41\nChinstrap penguin (Pygoscelis antarctica)\nAnvers\nDream\nAdult, 1 Egg Stage\nN74A1\nYes\n11/24/08\n49.0\n19.5\n210.0\n3950.0\nMALE\n9.53262\n-24.66867\nNaN\n\n\n2\nPAL0708\n4\nGentoo penguin (Pygoscelis papua)\nAnvers\nBiscoe\nAdult, 1 Egg Stage\nN32A2\nYes\n11/27/07\n50.0\n15.2\n218.0\n5700.0\nMALE\n8.25540\n-25.40075\nNaN\n\n\n3\nPAL0708\n15\nGentoo penguin (Pygoscelis papua)\nAnvers\nBiscoe\nAdult, 1 Egg Stage\nN38A1\nYes\n12/3/07\n45.8\n14.6\n210.0\n4200.0\nFEMALE\n7.79958\n-25.62618\nNaN\n\n\n4\nPAL0809\n34\nChinstrap penguin (Pygoscelis antarctica)\nAnvers\nDream\nAdult, 1 Egg Stage\nN65A2\nYes\n11/24/08\n51.0\n18.8\n203.0\n4100.0\nMALE\n9.23196\n-24.17282\nNaN\n\n\n\n\n\n\n\nWe first extract the species name for data presentation purposed, drop unnecessary columns, remove missing values, and filter out any invalid data. We return the processed feature set (X_train) and target species labels (y_train).\n\nfrom sklearn.preprocessing import LabelEncoder\n\n# Mapping full species names exclude scientific names\ntrain[\"Species\"] = train[\"Species\"].str.split().str.get(0)\n\nle = LabelEncoder()\nle.fit(train[\"Species\"])\n\ndef prepare_data(df):\n  df = df.drop([\"studyName\", \"Sample Number\", \"Individual ID\", \"Date Egg\", \"Comments\", \"Region\"], axis = 1)\n  df = df[df[\"Sex\"] != \".\"]\n  df = df.dropna()\n  y = le.transform(df[\"Species\"])\n  df = df.drop([\"Species\"], axis = 1)\n  df = pd.get_dummies(df)\n  return df, y\n\nX_train, y_train = prepare_data(train)\n\nThis is what our formatted feature set looks like:\n\nX_train.head()\n\n\n\n\n\n\n\n\nCulmen Length (mm)\nCulmen Depth (mm)\nFlipper Length (mm)\nBody Mass (g)\nDelta 15 N (o/oo)\nDelta 13 C (o/oo)\nIsland_Biscoe\nIsland_Dream\nIsland_Torgersen\nStage_Adult, 1 Egg Stage\nClutch Completion_No\nClutch Completion_Yes\nSex_FEMALE\nSex_MALE\n\n\n\n\n0\n40.9\n16.6\n187.0\n3200.0\n9.08458\n-24.54903\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\nTrue\nFalse\n\n\n1\n49.0\n19.5\n210.0\n3950.0\n9.53262\n-24.66867\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\n\n\n2\n50.0\n15.2\n218.0\n5700.0\n8.25540\n-25.40075\nTrue\nFalse\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\n\n\n3\n45.8\n14.6\n210.0\n4200.0\n7.79958\n-25.62618\nTrue\nFalse\nFalse\nTrue\nFalse\nTrue\nTrue\nFalse\n\n\n4\n51.0\n18.8\n203.0\n4100.0\n9.23196\n-24.17282\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\n\n\n\n\n\n\n\n\n\nData Exploration\nThe pair plot below gives us a introduces us to our data with a wide array of visualizations. These pairwise relationships are a great starting point to begin understanding the nature of the data.\n\nimport seaborn as sns\nsns.set_theme()\nsns.pairplot(data=train, hue=\"Species\")\n\n\n\n\n\n\n\n\nI scanned the above plot for data pairs that I thought showed promise in indicating species differentiation.\nHere is the relationship between Culmen Length (mm) and Culmen Depth (mm):\n\nsns.jointplot(data = train, x = \"Culmen Length (mm)\", y = \"Culmen Depth (mm)\", hue = \"Species\")\n\n\n\n\n\n\n\n\nWe can see that the three species of Penguins fall into three more or less distinct regions of the scatter plot with minimal overlap. This suggests that Culmen Length and Culmen Depth could be good points of reference when training a classification model.\nBelow is a plot that demonstrates the relationship between Gender, Flipper Length, and Body Mass:\n\nsns.catplot(data = X_train, x = \"Sex_FEMALE\", y = \"Flipper Length (mm)\", hue = \"Body Mass (g)\")\n\n\n\n\n\n\n\n\nThe above plot shows us that flipper length and body mass are positively correlated. In addition, we see that Males penguins have a higher growth ceiling in terms of body mass and flipper length.\nThe figure below illustrated some interesting data pertaining to species distribution over the islands. In addition, it gives us insight on the flipper length by species.\n\nimport numpy as np\ntrain.groupby([\"Island\", \"Species\"])[\"Flipper Length (mm)\"].agg(mean_flipper_length_mm=\"mean\", std_flipper_length_mm=\"std\")\n\n\n\n\n\n\n\n\n\nmean_flipper_length_mm\nstd_flipper_length_mm\n\n\nIsland\nSpecies\n\n\n\n\n\n\nBiscoe\nAdelie\n188.636364\n6.570855\n\n\nGentoo\n216.752577\n5.933715\n\n\nDream\nAdelie\n190.133333\n6.780989\n\n\nChinstrap\n196.000000\n7.423419\n\n\nTorgersen\nAdelie\n191.195122\n6.626536\n\n\n\n\n\n\n\nWe can observe that not every species is found on every island. The Adelie Penguin the only penguin found on all three surveyed islands. The Gentoo penguin is found exclusively on Biscoe Island and the Chinstrap penguin is found exclusively on Dream Island. In addition, the Gentoo penguins have the largest and least variable mean flipper length. They are followed by the Chinstrap penguins in size, then the Adelie with the smallest mean flipper lengths. Adelie and Chinstrap flipper lengths may overlap quite a bit, potentially making flipper length an unreliable feature for classifying the two species.\n\n\nModel Training\nIn the following we will employ a Logistic Regression model to classify our penguins. An integral step is figuring out which features we want to use to train our model. My methodology for this is a the brute force approach of testing out all the possible combinations using the handy combinations tool. The combinations tool will be used in conjunction with the cross_val_score tool from sklearn that will cross validate to avoid overfitting to the data. This step will help us perform better on data that the model has never seen before.\nAfter encountering maximum iteration issues with the logistic regression model, I scaled the data with the StandardScaler to be more manageable for the model\n\nfrom itertools import combinations\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import cross_val_score\n\n\nall_qual_cols = [\"Clutch Completion\", \"Sex\", \"Island\"]\nall_quant_cols = ['Culmen Length (mm)', 'Culmen Depth (mm)', 'Flipper Length (mm)', 'Body Mass (g)', 'Delta 15 N (o/oo)', 'Delta 13 C (o/oo)']\n\nLR = LogisticRegression()\nscaler = StandardScaler()\n\nX_train[all_quant_cols] = scaler.fit_transform(X_train[all_quant_cols])\nscore = 0\nfinal_cols = []\n\n\nfor qual in all_qual_cols: \n  qual_cols = [col for col in X_train.columns if qual in col ]\n  for pair in combinations(all_quant_cols, 2):\n    cols = qual_cols + list(pair) \n    LR.fit(X_train[cols], y_train)\n    cross_val_scores = cross_val_score(LR, X_train[cols], y_train, cv = 10)\n    if cross_val_scores.mean() &gt; score:\n      score = cross_val_scores.mean()\n      final_cols = cols\n\nprint(f\"The best model scored {score*100}% accuracy when testing on training data using: \\n{final_cols}\")    \n\nThe best model scored 99.21538461538461% accuracy when testing on training data using: \n['Island_Biscoe', 'Island_Dream', 'Island_Torgersen', 'Culmen Length (mm)', 'Culmen Depth (mm)']\n\n\nNow we have a repeatable, quantitative approach to justify training our model on the following features: Island, Culmen Length (mm), Culmen Depth (mm)\nI rearrange final_cols below to lead with quantitative features to conform to the graphing parameters that I will present later\n\nfinal_cols = ['Culmen Length (mm)', 'Culmen Depth (mm)', 'Island_Biscoe', 'Island_Dream', 'Island_Torgersen']\n\nLR = LogisticRegression()\nLR.fit(X_train[final_cols], y_train)\nLR.score(X_train[final_cols], y_train)\n\n0.99609375\n\n\nOur model performed with ~99% accuracy when using our selected three features and testing on our training data. This validates some of our visual predictions we identified in our exploration section. This is a great accuracy to have… however we are still testing our model on the data it was trained with. Next we will test it against unseen data!\n\ntest_url = \"https://raw.githubusercontent.com/PhilChodrow/ml-notes/main/data/palmer-penguins/test.csv\"\ntest = pd.read_csv(test_url)\n\ntest[\"Species\"] = test[\"Species\"].str.split().str.get(0)\n\nX_test, y_test = prepare_data(test)\nX_test[all_quant_cols] = scaler.fit_transform(X_test[all_quant_cols])\n\nLR.score(X_test[final_cols], y_test)\n\n1.0\n\n\nWow! We achieved an 100% testing accuracy on our test data! In context, we were able to correctly classify what type of penguin an individual was based on what island they were on and their culmen length and depth.\n\n\nEvaluation\nThe following block sets up a plot panel of decision regions that represent our classifier.\n\nfrom matplotlib import pyplot as plt\n\n\nfrom matplotlib.patches import Patch\n\ndef plot_regions(model, X, y):\n    \n    x0 = X[X.columns[0]]\n    x1 = X[X.columns[1]]\n    qual_features = X.columns[2:]\n    \n    fig, axarr = plt.subplots(1, len(qual_features), figsize = (9, 4))\n\n    # create a grid\n    grid_x = np.linspace(x0.min(),x0.max(),501)\n    grid_y = np.linspace(x1.min(),x1.max(),501)\n    xx, yy = np.meshgrid(grid_x, grid_y)\n    \n    XX = xx.ravel()\n    YY = yy.ravel()\n\n    for i in range(len(qual_features)):\n      XY = pd.DataFrame({\n          X.columns[0] : XX,\n          X.columns[1] : YY\n      })\n\n      for j in qual_features:\n        XY[j] = 0\n\n      XY[qual_features[i]] = 1\n\n      p = model.predict(XY)\n      p = p.reshape(xx.shape)\n      \n      \n      # use contour plot to visualize the predictions\n      axarr[i].contourf(xx, yy, p, cmap = \"jet\", alpha = 0.2, vmin = 0, vmax = 2)\n      \n      ix = X[qual_features[i]] == 1\n      # plot the data\n      axarr[i].scatter(x0[ix], x1[ix], c = y[ix], cmap = \"jet\", vmin = 0, vmax = 2)\n      \n      axarr[i].set(xlabel = X.columns[0], \n            ylabel  = X.columns[1], \n            title = qual_features[i])\n      \n      patches = []\n      for color, spec in zip([\"red\", \"green\", \"blue\"], [\"Adelie\", \"Chinstrap\", \"Gentoo\"]):\n        patches.append(Patch(color = color, label = spec))\n\n      plt.legend(title = \"Species\", handles = patches, loc = \"best\")\n      \n      plt.tight_layout()\n\n\nplot_regions(LR, X_train[final_cols], y_train)\n\n\n\n\n\n\n\n\nAs we noted in our exploration, not all penguins are found on all islands. This mean that our model essentially only had to account for a maximum of two species of penguins on any given island. we can see that the Culmen Length and Depth were also clustered nicely to have clear linear segmentation for our decision regions.\nLets take a look at our confusion matrix:\n\nfrom sklearn.metrics import confusion_matrix\n\ny_test_pred = LR.predict(X_test[final_cols])\nC = confusion_matrix(y_test, y_test_pred)\nC\n\narray([[31,  0,  0],\n       [ 0, 11,  0],\n       [ 0,  0, 26]])\n\n\nAs we had a 100% testing accuracy, this is exactly the sort of confusion matrix we would expect. The diagonal representing our correct classifications. Above and below the diagonal are empty because we did not misclassify any penguins.\nHere is another way to digest the confusion matrix:\n\nfor i in range(3):\n    for j in range(3):\n        print(f\"There were {C[i,j]} {le.classes_[i]} penguins who were classified as {le.classes_[j]}.\")\n\nThere were 31 Adelie penguins who were classified as Adelie.\nThere were 0 Adelie penguins who were classified as Chinstrap.\nThere were 0 Adelie penguins who were classified as Gentoo.\nThere were 0 Chinstrap penguins who were classified as Adelie.\nThere were 11 Chinstrap penguins who were classified as Chinstrap.\nThere were 0 Chinstrap penguins who were classified as Gentoo.\nThere were 0 Gentoo penguins who were classified as Adelie.\nThere were 0 Gentoo penguins who were classified as Chinstrap.\nThere were 26 Gentoo penguins who were classified as Gentoo.\n\n\n\n\nDiscussion\nExploring the Palmer Penguins data is a great introduction to data analysis and machine learning. Our results highlighted the effectiveness of using Culmen Depth, Culmen Length and Island Location as predictive features to train a Logistic regression model. We began by exploring the data set. We set up a series of plots and tables that helped us contextualize the data and make predictions about which features of the data may be helpful. While this was useful for understanding the data we were working with, we needed a repeatable method for choosing our eventual three features. We then turned to training and testing logistic regression models on different feature combinations. We scored each combination with how it performed against the training data and was cross validated against smaller subsets of the data to avoid overfitting. Finally we used the cross validated features with the largest accuracy and tested them against a separate test data set. Here we achieved the desired 100% testing accuracy. Finally, we took a moment to evaluate these results by examining the decision regions, and looking at the confusion matrix. Visualizing decision regions highlighted how well logistic regression can separate species based on our selected features. The confusion matrix confirmed the reliability of our model as there were no misclassifications. This blog gave me good insight on data analysis and practical machine learning workflows. Several important takeaways were the importance of separating our training and testing data to ensure our model works on unseen data. The importance of cross validation is also key to not overfitting our data."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hello, my name is Lukka Wolff. Welcome to my Blog!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Awesome CSCI 0451 Blog",
    "section": "",
    "text": "Design and Impact of Automated Decision Systems\n\n\n\n\n\nDesign and Impact of Automated Decision Systems\n\n\n\n\n\nMar 5, 2025\n\n\nLukka Wolff\n\n\n\n\n\n\n\n\n\n\n\n\nClassifying Palmer Penguins\n\n\n\n\n\nClassifying Palmer Penguins using Machine Learning\n\n\n\n\n\nFeb 26, 2025\n\n\nLukka Wolff\n\n\n\n\n\n\n\n\n\n\n\n\nTimnit Gebru\n\n\n\n\n\nA new blog post that I just made!\n\n\n\n\n\nMar 10, 2023\n\n\nPhil Chodrow\n\n\n\n\n\n\n\n\n\n\n\n\nSecond Post\n\n\n\n\n\nA new blog post that I just made!\n\n\n\n\n\nMar 10, 2023\n\n\nPhil Chodrow\n\n\n\n\n\n\n\n\n\n\n\n\nHello Blog\n\n\n\n\n\nAn example blog post illustrating the key techniques you’ll need to demonstrate your learning in CSCI 0451.\n\n\n\n\n\nJan 10, 2023\n\n\nPhil Chodrow\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/new-new-test-post/index.html",
    "href": "posts/new-new-test-post/index.html",
    "title": "Timnit Gebru",
    "section": "",
    "text": "from source import Perceptron\np = Perceptron()\n\nI did it!!\nnot implemented\nThis is an example of the blog posts that you’ll submit as your primary form of learning demonstration in CSCI 0451. I created this post by modifying the file posts/example-blog-post/index.ipynb in VSCode. You can also use JupyterLab for this editing if you prefer. Finally, it is possible to write blog posts without using notebooks by writing .qmd files, as illustrated here."
  },
  {
    "objectID": "posts/new-new-test-post/index.html#math",
    "href": "posts/new-new-test-post/index.html#math",
    "title": "Timnit Gebru",
    "section": "Math",
    "text": "Math\nIn addition to regular text using the Markdown specification, you can also write mathematics, enclosed between dollar signs. The syntax for writing math is very similar to the syntax used in the \\(\\LaTeX\\) markup language. For example, $f(x) \\approx y$ renders to \\(f(x) \\approx y\\). To place complex mathematical expressions on their own lines, use double dollar signs. For example, the expression\n$$\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2$$\nrenders to:\n\\[\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2\\;.\\]\nBehind the scenes, math is powered by the MathJax engine. For more on how to write math, check this handy tutorial and quick reference."
  },
  {
    "objectID": "posts/Design and Impact of Automated Decision Systems/index.html",
    "href": "posts/Design and Impact of Automated Decision Systems/index.html",
    "title": "Design and Impact of Automated Decision Systems",
    "section": "",
    "text": "Abstract\nInsert here\n\n\nData\nWe are diving into a Credit Risk Dataset that simulates credit bureau data.\n\nimport pandas as pd\nurl = \"https://raw.githubusercontent.com/PhilChodrow/ml-notes/main/data/credit-risk/train.csv\"\ndf_train = pd.read_csv(url)\n\nHere is a first look at the raw data:\n\ndf_train.head()\n\n\n\n\n\n\n\n\nperson_age\nperson_income\nperson_home_ownership\nperson_emp_length\nloan_intent\nloan_grade\nloan_amnt\nloan_int_rate\nloan_status\nloan_percent_income\ncb_person_default_on_file\ncb_person_cred_hist_length\n\n\n\n\n0\n25\n43200\nRENT\nNaN\nVENTURE\nB\n1200\n9.91\n0\n0.03\nN\n4\n\n\n1\n27\n98000\nRENT\n3.0\nEDUCATION\nC\n11750\n13.47\n0\n0.12\nY\n6\n\n\n2\n22\n36996\nRENT\n5.0\nEDUCATION\nA\n10000\n7.51\n0\n0.27\nN\n4\n\n\n3\n24\n26000\nRENT\n2.0\nMEDICAL\nC\n1325\n12.87\n1\n0.05\nN\n4\n\n\n4\n29\n53004\nMORTGAGE\n2.0\nHOMEIMPROVEMENT\nA\n15000\n9.63\n0\n0.28\nN\n10\n\n\n\n\n\n\n\nI want to highlight several important features of this dataset.\n\nloan_percent_income is ratio of the loan amount to the individual’s income\nloan_int_rate is the annual interest rate on the loan.\nloan_status tells us whether or not the individual defaulted on their loan. This a a binary feature where 0 indicates the individual defaulted, and 1 indicates the loan was repaid in full. This is our Target Variable.\n\nLets have a look at how common defaulting is in our training data:\n\ndf_train[\"loan_status\"].value_counts(normalize=True)\n\nloan_status\n0    0.78242\n1    0.21758\nName: proportion, dtype: float64\n\n\nIn the dataset, around 21% of borrowers default on their loan. This is going to be the our base rate for prediction.\n\ndf_train[\"person_age\"].describe()\n\ncount    26064.000000\nmean        27.734385\nstd          6.362612\nmin         20.000000\n25%         23.000000\n50%         26.000000\n75%         30.000000\nmax        144.000000\nName: person_age, dtype: float64\n\n\nThere seems to be some slight errors in our data with the age of certain individuals. 144, although impressive, is highly unlikely. Thus, without context for why the data has such an outlier, I am going to filter our data to exclude persons over 100 years old. In addition, I will do some other data cleaning like removing NaN entries, one-hot encoding qualitative features, etc.\n\ndf_train = df_train[df_train[\"person_age\"] &lt; 100]\n\n\nfrom sklearn.preprocessing import LabelEncoder\n\nle = LabelEncoder()\nle.fit(df_train[\"cb_person_default_on_file\"])\n\ndf_train[\"cb_person_default_on_file\"] = le.transform(df_train[\"cb_person_default_on_file\"])\n\ndf_train = df_train.dropna()\n\n\ndf_train.head()\n\n\n\n\n\n\n\n\nperson_age\nperson_income\nperson_home_ownership\nperson_emp_length\nloan_intent\nloan_grade\nloan_amnt\nloan_int_rate\nloan_status\nloan_percent_income\ncb_person_default_on_file\ncb_person_cred_hist_length\n\n\n\n\n1\n27\n98000\nRENT\n3.0\nEDUCATION\nC\n11750\n13.47\n0\n0.12\n1\n6\n\n\n2\n22\n36996\nRENT\n5.0\nEDUCATION\nA\n10000\n7.51\n0\n0.27\n0\n4\n\n\n3\n24\n26000\nRENT\n2.0\nMEDICAL\nC\n1325\n12.87\n1\n0.05\n0\n4\n\n\n4\n29\n53004\nMORTGAGE\n2.0\nHOMEIMPROVEMENT\nA\n15000\n9.63\n0\n0.28\n0\n10\n\n\n6\n21\n21700\nRENT\n2.0\nHOMEIMPROVEMENT\nD\n5500\n14.91\n1\n0.25\n0\n2\n\n\n\n\n\n\n\n\n\nExploration\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nsns.set_theme(style=\"whitegrid\")\n\n\nsns.displot(data=df_train, x=\"loan_percent_income\", hue=\"loan_status\", kind=\"kde\", bw_adjust=0.9, fill=True, alpha=0.25)\n\n\n\n\n\n\n\n\nKernel Density Estimation (KDE)\n\nsns.kdeplot(data=df_train, x=\"cb_person_cred_hist_length\", y=\"loan_int_rate\", cmap=\"rocket\", fill=True)\n\n\n\n\n\n\n\n\n\nsns.catplot(data=df_train, kind=\"bar\", x=\"person_home_ownership\", y=\"loan_percent_income\", hue=\"loan_status\")\n\n\n\n\n\n\n\n\n\nimport numpy as np\n\nbins = [0, 5, 10, 15, 20, np.inf]\nlabels = ['0-5', '5-10', '10-15', '15-20', '20+']\n\ndf_train.groupby(\n    pd.cut(df_train['cb_person_cred_hist_length'], bins=bins, labels=labels), observed=True\n)[['person_age', 'person_emp_length']].agg(['mean'])\n\n\n\n\n\n\n\n\nperson_age\nperson_emp_length\n\n\n\nmean\nmean\n\n\ncb_person_cred_hist_length\n\n\n\n\n\n\n0-5\n24.253351\n4.277778\n\n\n5-10\n29.975727\n5.417458\n\n\n10-15\n40.011823\n5.982576\n\n\n15-20\n41.297771\n6.046178\n\n\n20+\n57.318471\n5.923567\n\n\n\n\n\n\n\n\n\nModel Building\n\nfrom itertools import combinations\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import cross_val_score\n\n\nall_qual_cols = [\"person_home_ownership\", \"loan_intent\"]\nall_quant_cols = [\"person_age\", \"person_income\", \"person_emp_length\", \"loan_amnt\", \"loan_int_rate\", \"loan_percent_income\", \"cb_person_cred_hist_length\", \"cb_person_default_on_file\"]\n\ndf_train = pd.get_dummies(df_train)\n\nLR = LogisticRegression()\nscaler = StandardScaler()\n\ndf_train[all_quant_cols] = scaler.fit_transform(df_train[all_quant_cols])\nscore = 0\nfinal_cols = []\n\nX_train = df_train.drop(columns = \"loan_status\")\ny_train = df_train[\"loan_status\"]\n\nfor qual in all_qual_cols: \n  qual_cols = [col for col in X_train.columns if qual in col ]\n  for pair in combinations(all_quant_cols, 2):\n    cols = qual_cols + list(pair) \n    LR.fit(X_train[cols], y_train)\n    cross_val_scores = cross_val_score(LR, X_train[cols], y_train, cv = 5)\n    if cross_val_scores.mean() &gt; score:\n      score = cross_val_scores.mean()\n      final_cols = cols\n\n\nprint(f\"The best model scored {score*100:.3f}% accuracy when testing on training data using: \\n{final_cols}\")    \n\nThe best model scored 84.740% accuracy when testing on training data using: \n['person_home_ownership_MORTGAGE', 'person_home_ownership_OTHER', 'person_home_ownership_OWN', 'person_home_ownership_RENT', 'person_emp_length', 'loan_percent_income']\n\n\n\ndef linear_score(X, w):\n    return X@w\n\n\nLR.fit(X_train[final_cols], y_train)\nLR.coef_\n\narray([[-0.49445373,  0.15477064, -1.57794139,  0.50619128, -0.08065826,\n         0.90378892]])\n\n\n\nw = LR.coef_[0]\ns = linear_score(df_train[final_cols], w)\n\n\nfig, ax = plt.subplots(1, 1, figsize = (6, 4))\nhist = ax.hist(s, bins = 50, color = \"purple\", alpha = 0.6, linewidth = 0.75, edgecolor = \"black\")\nlabs = ax.set(xlabel = r\"Score $s$\", ylabel = \"Frequency\") \n\n\n\n\n\n\n\n\n\ndef calculate_profit(df_train):\n    return (df_train[\"loan_amnt\"]*(1 + 0.25*(df_train[\"loan_int_rate\"]/ 100))**10) - df_train[\"loan_amnt\"]\n\ndef calculate_loss(df_train):\n    return (df_train[\"loan_amnt\"]*(1 + 0.25*(df_train[\"loan_int_rate\"]/ 100))**3) - (1.7*df_train[\"loan_amnt\"])\n\n\nbest_profit = 0\nbest_threshold = 0\n\nfig, ax = plt.subplots(1, 1, figsize = (6, 4))\nfor t in np.linspace(-4, 4, 101): \n    y_pred = s &gt;= t\n    tn = ((y_pred == 0) & (y_train == 0))\n    fn = ((y_pred == 0) & (y_train == 1))\n\n    gain = calculate_profit(df_train[tn]).sum() + calculate_loss(df_train[fn]).sum()\n    ax.scatter(t, gain, color = \"steelblue\", s = 10)\n    if gain &gt; best_profit: \n        best_profit = gain\n        best_threshold = t\n\n\nax.axvline(best_threshold, linestyle = \"-.\", color = \"grey\", zorder = -10)\nlabs = ax.set(xlabel = r\"Threshold $t$\", ylabel = \"Net benefit\", title = f\"Best benefit ${best_profit:.2f} at best threshold t = {best_threshold:.3f}\")\n\n\n\n\n\n\n\n\n\n\nBank Evaluation\nHere we are importing the test data set and applying the same preprocessing steps that we used on the training data.\n\nurl = \"https://raw.githubusercontent.com/PhilChodrow/ml-notes/main/data/credit-risk/test.csv\"\ndf_test = pd.read_csv(url)\n\ndf_test[\"cb_person_default_on_file\"] = le.transform(df_test[\"cb_person_default_on_file\"])\ndf_test = df_test.dropna()\ndf_test = pd.get_dummies(df_test)\ndf_test[all_quant_cols] = scaler.fit_transform(df_test[all_quant_cols])\n\nX_test = df_test.drop(columns = \"loan_status\")\ny_test = df_test[\"loan_status\"]\n\n\ntest_score = linear_score(df_test[final_cols], w)\ny_pred = test_score &gt; best_threshold\n\ntest_tn = ((y_pred == 0) & (y_test == 0))\ntest_fn = ((y_pred == 0) & (y_test == 1))\n\ntest_gain = calculate_profit(df_test.loc[test_tn]).sum() + calculate_loss(df_test.loc[test_fn]).sum()\n\n\nprint(f\"The net benefit on the test set is ${test_gain:.2f}\")\n\nThe net benefit on the test set is $96.45\n\n\nThis is blasphemous!\n\nfrom sklearn.metrics import confusion_matrix\n\nconfusion_matrix(y_test, y_pred, normalize = \"true\")\n\narray([[0.88819039, 0.11180961],\n       [0.50352388, 0.49647612]])\n\n\n\n\nBorrower’s Evaluation"
  }
]